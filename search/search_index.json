{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This repo contains some solved problems from several online judges. The codes and notes are just kept here as a learning record.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Exercises in Programming Contest Challenge Book, 2e: work in progress</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/","title":"Exercises in *Programming Contest Challenge Book, 2e*","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#exercises-in-programming-contest-challenge-book-2e","title":"Exercises in Programming Contest Challenge Book, 2e","text":"<p>\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\uff08\u7b2c2\u7248\uff09\u7ec3\u4e60\u9898</p>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#21","title":"2.1","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1979","title":"POJ 1979","text":"<p> Problem  Code</p> <ul> <li>Naive DFS.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-0118","title":"AOJ 0118","text":"<p> Problem  Code</p> <ul> <li>Naive DFS from every unvisited vertex of the graph.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-0033","title":"AOJ 0033","text":"<p> Problem  Code</p> <ul> <li>Naive DFS works since n=10n = 10n=10. There are at most 2n=10242^n = 10242n=1024 possiblities.</li> <li>Greedy algorithm also works. Keep the two uppermost values in both cylinders: lll and rrr, where (l&lt;r)(l &lt; r)(l&lt;r). For a newly-dropped ball of value eee:<ul> <li>If e&lt;l&lt;re &lt; l &lt; re&lt;l&lt;r, it can be placed on neither side.</li> <li>If l&lt;e&lt;rl &lt; e &lt; rl&lt;e&lt;r, it can only be placed on lll.</li> <li>If l&lt;r&lt;el &lt; r &lt; el&lt;r&lt;e, it can be placed on either lll or rrr. But it should be placed on rrr since placing eee on lll is never better than placing eee on rrr. </li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3009","title":"POJ 3009","text":"<p> Problem  Code</p> <ul> <li>DFS and pruning.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-0558","title":"AOJ 0558","text":"<p> Problem  Code</p> <ul> <li>BFS: The mouse must eat cheeses in the order of 1,2,\u2026,N1, 2, \\dots, N1,2,\u2026,N.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3669","title":"POJ 3669","text":"<p> Problem  Code</p> <ul> <li>BFS:<ul> <li>The target of search is to find a safe location which is not destroyed by the meteors. Use BFS and keep all reachable points in the queue until the target is reached.</li> <li>Consider a point (xi,yi)(x_i, y_i)(xi\u200b,yi\u200b) that is destoryed by a meteor at tit_iti\u200b at the first time. The accessible time of (xi,yi)(x_i, y_i)(xi\u200b,yi\u200b) is [0,ti)[0, t_i)[0,ti\u200b). Use <code>G[x][y]</code> to represent the upper bound of accessible time for point (xi,yi)(x_i, y_i)(xi\u200b,yi\u200b), which is tmint_{\\text{min}}tmin\u200b for all meteors that destory (xi,yi)(x_i, y_i)(xi\u200b,yi\u200b). <code>G[x][y]</code> should be considered when we traverse through the neighbor points.</li> <li>0\u2264xi,yi\u22643000 \\le x_i, y_i \\le 3000\u2264xi\u200b,yi\u200b\u2264300 implies <code>G[302][302]</code> is enough. All points (301,\u2217)(301, *)(301,\u2217) or (\u2217,301)(*, 301)(\u2217,301) must be safe.</li> <li>The solution, if possible, should be in the range [0,1000][0, 1000][0,1000] since 0\u2264ti\u226410000 \\le t_i \\le 10000\u2264ti\u200b\u22641000.</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-0121","title":"AOJ 0121","text":"<p> Problem  Code</p> <ul> <li>BFS, bit manipulation, and precomputation: <ul> <li>The result can be precomputed since 8!=403208! = 403208!=40320 is small.</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2718","title":"POJ 2718","text":"<p> Problem  Code</p> <ul> <li>Exhausive search: <code>std::next_permutation</code></li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3187","title":"POJ 3187","text":"<p> Problem  Code</p> <ul> <li>Binomial expansion, Pascal's triangle, and Pascal's rule (nk)=(n\u22121k)+(n\u22121k\u22121){n \\choose k} = {n - 1 \\choose k} + { n - 1 \\choose k - 1} (kn\u200b)=(kn\u22121\u200b)+(k\u22121n\u22121\u200b)</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3050","title":"POJ 3050","text":"<p> Problem  Code</p> <ul> <li>We use DFS directly because 5\u00d75\u00d745=25600&lt;1055 \\times 5 \\times 4^5 = 25600 &lt; 10^{5}5\u00d75\u00d745=25600&lt;105</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-0525","title":"AOJ 0525","text":"<p> Problem  Code</p> <ul> <li>State compression: 2R+C\u21922R\u22c5C(1\u2264R\u226410,1\u2264C\u2264104)2^{R + C} \\to  2^R \\cdot C \\quad (1 \\le R \\le 10, 1 \\le C \\le 10^4)2R+C\u21922R\u22c5C(1\u2264R\u226410,1\u2264C\u2264104).</li> <li>Bit manipulation: <code>__built_in_popcount</code> in GCC or <code>std::popcount</code> since C++20.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#22","title":"2.2","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2376","title":"POJ 2376","text":"<p> Problem  Code</p> <ul> <li>The unassigned shift [L,T][L, T][L,T] can be assigned to the cow iii that is available on the interval [Li,Ri][L_i, R_i][Li\u200b,Ri\u200b] as long as Li\u2264LL_i \\le LLi\u200b\u2264L. And among all feasible choices, we choose the one with maximum RiR_iRi\u200b, which makes the remaining unassigned shift becomes [Ri+1,T][R_i + 1, T][Ri\u200b+1,T].</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1328","title":"POJ 1328","text":"<p> Problem  Code</p> <ul> <li>Each island corresponds to an interval [ai,bi][a_i, b_i][ai\u200b,bi\u200b] on the xxx-axis, on which we could install a radar to cover the island.</li> <li>Sort the intervals [ai,bi][a_i, b_i][ai\u200b,bi\u200b] in nondescreasing order: [ai,bi]&lt;[aj,bj] \u27fa ((ai&lt;bj)\u2228(ai=aj\u2227bi&lt;bj))[a_i, b_i] &lt; [a_j, b_j] \\iff ((a_i &lt; b_j) \\lor (a_i = a_j \\land b_i &lt; b_j))[ai\u200b,bi\u200b]&lt;[aj\u200b,bj\u200b]\u27fa((ai\u200b&lt;bj\u200b)\u2228(ai\u200b=aj\u200b\u2227bi\u200b&lt;bj\u200b)). </li> <li>For i=1,2,\u2026,Ni = 1, 2, \\dots, Ni=1,2,\u2026,N, make the current radar cover islands as many as possible.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3190","title":"POJ 3190","text":"<p> Problem  Code</p> <ul> <li>Sort the intervals [ai,bi][a_i, b_i][ai\u200b,bi\u200b] in nondescreasing order: [ai,bi]&lt;[aj,bj] \u27fa ai&lt;bj[a_i, b_i] &lt; [a_j, b_j] \\iff a_i &lt; b_j[ai\u200b,bi\u200b]&lt;[aj\u200b,bj\u200b]\u27faai\u200b&lt;bj\u200b. </li> <li>For the cow with interval [ai,bi][a_i, b_i][ai\u200b,bi\u200b]:<ul> <li>If none of the stall is available for it, add a new stall.</li> <li>Else, for all available stalls, choose any one of them. We choose the one that is available as early as possible.</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2393","title":"POJ 2393","text":"<p> Problem  Code</p> <ul> <li>The cost chosen in the nnn-th week should be the minimum cost from week 111 to week nnn, which is:   <p>min\u20611\u2264i\u2264n{ci+s\u22c5(n\u2212i)}=min\u20611\u2264i\u2264n{ci\u2212s\u22c5i}+s\u22c5n \\min_{1 \\le i \\le n}{ \\lbrace c_i + s \\cdot (n - i) \\rbrace } = \\min_{1 \\le i \\le n}{\\lbrace c_i - s \\cdot i \\rbrace}  + s \\cdot n 1\u2264i\u2264nmin\u200b{ci\u200b+s\u22c5(n\u2212i)}=1\u2264i\u2264nmin\u200b{ci\u200b\u2212s\u22c5i}+s\u22c5n</p></li> <li>CAUTION: Since N\u22c5C\u22c5Y=104\u22c55000\u22c5104=5\u22c51012&lt;240N \\cdot C \\cdot Y = 10^{4} \\cdot 5000 \\cdot 10^4 = 5 \\cdot 10^{12} &lt; 2^{40}N\u22c5C\u22c5Y=104\u22c55000\u22c5104=5\u22c51012&lt;240,<code>long long</code> should be used.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1017","title":"POJ 1017","text":"<p> Problem  Code</p> <ul> <li>Greedy algorithm: Deliver packets in decreasing order.<ul> <li>Deliver the packet of 6\u00d766 \\times 66\u00d76, 5\u00d755 \\times 55\u00d75, 4\u00d744 \\times 44\u00d74, 3\u00d733 \\times 33\u00d73 and remember the space left for 2\u00d722 \\times 22\u00d72 and 1\u00d711 \\times 11\u00d71.</li> <li>Deliver 2\u00d722 \\times 22\u00d72: use the space left previously for 2\u00d722 \\times 22\u00d72 as much as possible and then transform the unused space for 2\u00d722 \\times 22\u00d72 into 1\u00d711 \\times 11\u00d71.</li> <li>Deliver 1\u00d711 \\times 11\u00d71: use space left previously for 1\u00d711 \\times 11\u00d71 as much as possible.</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3040","title":"POJ 3040","text":"<p> Problem  Code</p> <ul> <li>To pay at least CCC cents, choose coins in two steps:<ul> <li>Choose coins from large to small to pay some cents that is close to but not exceeding CCC.</li> <li>Choose coins from small to large to pay the remaining cents.</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1862","title":"POJ 1862","text":"<p> Problem  Code</p> <ul> <li> <p>The result is     <p>2N\u22121\u22c5m10.5N\u22121\u22c5m20.5N\u22121\u22c5m30.5N\u22122\u22efmk0.5N+1\u2212k\u22efmN\u221210.52\u22c5mN0.5 2^{N-1} \\cdot m_{1}^{0.5^{N-1}} \\cdot m_{2}^{0.5^{N-1}} \\cdot m_{3}^{0.5^{N-2}} \\cdots  m_{k}^{0.5^{N+1-k}} \\cdots m_{N-1}^{0.5^2} \\cdot m_{N}^{0.5} 2N\u22121\u22c5m10.5N\u22121\u200b\u22c5m20.5N\u22121\u200b\u22c5m30.5N\u22122\u200b\u22efmk0.5N+1\u2212k\u200b\u22efmN\u221210.52\u200b\u22c5mN0.5\u200b</p>     which is minimized when     <p>m1\u2265m2\u2265m3\u2265\u22ef\u2265mN\u22121\u2265mN m_1 \\ge m_2 \\ge m_3 \\ge \\cdots \\ge m_{N-1} \\ge m_N m1\u200b\u2265m2\u200b\u2265m3\u200b\u2265\u22ef\u2265mN\u22121\u200b\u2265mN\u200b</p></p> </li> <li> <p>Proof: Assume 1&lt;i&lt;j1 &lt; i &lt; j1&lt;i&lt;j and mi\u2265mj&gt;0m_i \\ge m_j &gt; 0mi\u200b\u2265mj\u200b&gt;0, exchange the iii-th and jjj-th element make the result smaller since     <p>mi0.5N+1\u2212i\u22c5mj0.5N+1\u2212jmj0.5N+1\u2212i\u22c5mi0.5N+1\u2212j=(mimj)0.5j\u2212i\u22651  \\frac{m_i^{0.5^{N+1-i}} \\cdot m_j^{0.5^{N+1-j}}}{m_j^{0.5^{N+1-i}} \\cdot m_i^{0.5^{N+1-j}}} = (\\frac{m_i}{m_j})^{0.5^{j - i}} \\ge 1 mj0.5N+1\u2212i\u200b\u22c5mi0.5N+1\u2212j\u200bmi0.5N+1\u2212i\u200b\u22c5mj0.5N+1\u2212j\u200b\u200b=(mj\u200bmi\u200b\u200b)0.5j\u2212i\u22651</p></p> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3262","title":"POJ 3262","text":"<p> Problem  Code</p> <ul> <li>Intuition: Transport the cows with larger DT\\frac{D}{T}TD\u200b as soon as possible, since they eat faster and the time to transport them is shorter.</li> <li>Proof: The difference of the flower losses introduced by exchanging the iii-th and the (i+1)(i+1)(i+1)-th is Ti+1\u22c5Di\u2192Ti\u22c5Di+1T_{i + 1} \\cdot D_{i} \\to T_i \\cdot D_{i + 1}Ti+1\u200b\u22c5Di\u200b\u2192Ti\u200b\u22c5Di+1\u200b. That's to say, exchanging any consecutive pair that satisfies Ti+1\u22c5Di&gt;Ti\u22c5Di+1T_{i + 1} \\cdot D_{i} &gt; T_i \\cdot D_{i + 1}Ti+1\u200b\u22c5Di\u200b&gt;Ti\u200b\u22c5Di+1\u200b  can generate less flower losses.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#23","title":"2.3","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3176","title":"POJ 3176","text":"<p> Problem  Code</p> <ul> <li> <p>dp[i][j]={max\u2061{dp[i\u22121][j\u22121],dp[i\u22121][j]}+a[i][j](1\u2264j\u2264i\u2264N)0(otherwise) dp[i][j] = \\begin{cases} \\max \\lbrace dp[i - 1][j - 1], dp[i - 1][j] \\rbrace   + \\text{a}[i][j] &amp; (1 \\le j \\le i \\le N) \\\\ 0 &amp; (\\text{otherwise}) \\end{cases} dp[i][j]={max{dp[i\u22121][j\u22121],dp[i\u22121][j]}+a[i][j]0\u200b(1\u2264j\u2264i\u2264N)(otherwise)\u200b</p> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2229","title":"POJ 2229","text":"<p> Problem  Code</p> <ul> <li>Hint: Is 111 in the sum or not?</li> <li> <p>dp[n]={0(n=0)dp[n\u22121](n&gt;0,n mod 2=1)dp[n2]+dp[n\u22121](n&gt;0,n mod 2=0) dp[n] = \\begin{cases}     0                                           &amp; (n = 0) \\\\     dp[n - 1]                            &amp; (n &gt; 0, n \\bmod 2 = 1) \\\\     dp[\\frac{n}{2}] + dp[n - 1]   &amp; (n &gt; 0, n \\bmod 2 = 0) \\\\ \\end{cases} dp[n]=\u23a9\u23a8\u23a7\u200b0dp[n\u22121]dp[2n\u200b]+dp[n\u22121]\u200b(n=0)(n&gt;0,nmod2=1)(n&gt;0,nmod2=0)\u200b</p> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2385","title":"POJ 2385","text":"<p> Problem  Code</p> <ul> <li>Define state as (t,w,r)(t, w, r)(t,w,r):<ul> <li>t\u2254t \\coloneqqt:=  current minute: 0,1,2,3,\u2026,T0, 1, 2, 3, \\dots, T0,1,2,3,\u2026,T.</li> <li>w\u2254w \\coloneqqw:= number of chances left to walk to another tree: W,W\u22121,\u2026,1,0W, W-1, \\dots, 1, 0W,W\u22121,\u2026,1,0.</li> <li>r\u2254r \\coloneqqr:= tree number: 111 or 222.</li> <li>at\u2254a_t \\coloneqqat\u200b:= the tree that will drop an apple at minute ttt.</li> <li>f(t,w,r)\u2254f(t, w, r) \\coloneqqf(t,w,r):= maximum number of apples that can be caught from time ttt on condition that the cow is currently under tree rrr and has last www chances to walk to another tree.</li> <li><p>{f(T,\u2217,\u2217)=0f(t,0,r)=f(t+1,0,r)+[at=r]f(t,w,r)=max\u2061{f(t+1,w,r)+[at=r],f(t+1,w\u22121,3\u2212r)+[at\u2260r]} \\left\\{ \\begin{align*}   &amp; f(T, *, *) = 0  \\\\   &amp; f(t, 0, r) = f(t + 1, 0, r) + [a_t = r] \\\\   &amp; f(t, w, r) = \\max{\\{ f(t + 1, w, r) + [a_t = r],  f(t + 1, w - 1, 3 - r) + [a_t \\ne r]\\}} \\\\ \\end{align*} \\right. \u23a9\u23a8\u23a7\u200b\u200bf(T,\u2217,\u2217)=0f(t,0,r)=f(t+1,0,r)+[at\u200b=r]f(t,w,r)=max{f(t+1,w,r)+[at\u200b=r],f(t+1,w\u22121,3\u2212r)+[at\u200b\ue020=r]}\u200b</p></li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3616","title":"POJ 3616","text":"<p> Problem  Code</p> <ul> <li>Sort the intervals by the ending hour.</li> <li>dp[i+1]\u2254dp[i + 1] \\coloneqq dp[i+1]:= maximum amount of milk that can be produced in the first iii intervals.</li> <li>Ai\u2254A_i \\coloneqq Ai\u200b:= starting hour of the iii-th interval.</li> <li>Bi\u2254B_i \\coloneqq Bi\u200b:= ending hour of the iii-th interval.</li> <li>Wi\u2254W_i \\coloneqq Wi\u200b:= efficiency of the iii-th interval.</li> <li> <p>dp[i]={0(i=0)dp[k]+Wi(i&gt;0,k\u00a0is\u00a0the\u00a0max\u00a0ending\u00a0hour\u00a0that\u00a0satisfies\u00a0Bk+R\u2264Ai) dp[i] = \\begin{cases}   0 &amp; (i = 0) \\\\   dp[k] + W_i &amp; (i &gt; 0, k \\text{ is the max ending hour that satisfies } B_k + R \\le A_i) \\\\ \\end{cases} dp[i]={0dp[k]+Wi\u200b\u200b(i=0)(i&gt;0,k\u00a0is\u00a0the\u00a0max\u00a0ending\u00a0hour\u00a0that\u00a0satisfies\u00a0Bk\u200b+R\u2264Ai\u200b)\u200b</p> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3280","title":"POJ 3280","text":"<p> Problem  Code</p> <ul> <li>In this problem, adding a character or deleting a character would make the same contribution to generate a palindrome. So we always choose the way with less cost.</li> <li>c[si]\u2254c[s_i] \\coloneqqc[si\u200b]:= the less cost between adding and deleting the character sis_isi\u200b.</li> <li>dp[i][j]\u2254dp[i][j] \\coloneqqdp[i][j]:= the cost to change the substring si,si+1,\u22ef ,sj\u22121,sj s_i, s_{i + 1}, \\cdots, s_{j-1}, s_j si\u200b,si+1\u200b,\u22ef,sj\u22121\u200b,sj\u200b into palindrome.</li> <li> <p>dp[i][j]={0(i\u2265j)dp[i+1][j\u22121](i&lt;j\u2227si=sj)min\u2061{dp[i+1][j]+c[si],dp[i][j\u22121]+c[sj]}(i&lt;j\u2227si=sj) dp[i][j] = \\begin{cases}   0 &amp; (i \\ge j) \\\\   dp[i + 1][j - 1] &amp; (i &lt; j \\land s_i = s_j) \\\\   \\min{\\{ dp[i + 1][j] + c[s_i], dp[i][j - 1] + c[s_j] \\}} &amp; (i &lt; j \\land s_i = s_j) \\\\ \\end{cases} dp[i][j]=\u23a9\u23a8\u23a7\u200b0dp[i+1][j\u22121]min{dp[i+1][j]+c[si\u200b],dp[i][j\u22121]+c[sj\u200b]}\u200b(i\u2265j)(i&lt;j\u2227si\u200b=sj\u200b)(i&lt;j\u2227si\u200b=sj\u200b)\u200b</p> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1742","title":"POJ 1742","text":"<p> Problem  Code</p> <ul> <li>dp[i+1][j]\u2254dp[i + 1][j] \\coloneqq dp[i+1][j]:= maximum number of coins of value AiA_iAi\u200b left when the exact price paid is jjj.     \u22121-1\u22121 if there's no feasible solution.</li> <li> <p>dp[i+1][j]={Ci(dp[i][j]\u22650)\u22121(j&lt;Ai\u2228dp[i+1][j\u2212Ai]\u22640)dp[i+1][j\u2212Ai]\u22121(otherwise) dp[i + 1][j] = \\begin{cases}   C_i                           &amp; (dp[i][j] \\ge 0) \\\\   -1                            &amp; (j &lt; A_i \\lor dp[i + 1][j - A_i] \\le 0) \\\\   dp[i + 1][j - A_i] - 1 &amp; (\\text{otherwise}) \\\\ \\end{cases} dp[i+1][j]=\u23a9\u23a8\u23a7\u200bCi\u200b\u22121dp[i+1][j\u2212Ai\u200b]\u22121\u200b(dp[i][j]\u22650)(j&lt;Ai\u200b\u2228dp[i+1][j\u2212Ai\u200b]\u22640)(otherwise)\u200b</p> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3046","title":"POJ 3046","text":"<p> Problem  Code</p> <ul> <li>dp[i][j]\u2254dp[i][j] \\coloneqq dp[i][j]:= number of jjj-nary sets that can be formed by the first iii ant families.</li> <li> <p>dp[i][j]=\u2211t=max\u2061{0,j\u2212Ni}jdp[i\u22121][t] dp[i][j] = \\sum_{t = \\max{\\{0, j - N_i\\}}}^{j} {dp[i - 1][t]} dp[i][j]=t=max{0,j\u2212Ni\u200b}\u2211j\u200bdp[i\u22121][t]</p> </li> <li>Optimization: Prefix Sum.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3181","title":"POJ 3181","text":"<p> Problem  Code</p> <ul> <li>dp[i][j]\u2254dp[i][j] \\coloneqq dp[i][j]:= the number of ways to spend jjj dollars to buy from the first iii tools.</li> <li> <p>dp[i][j]=dp[i\u22121][j]+dp[i\u22121][j\u2212i]+dp[i\u22121][j\u22122\u22c5i]+\u22ef+dp[i\u22121][j\u2212\u230aji\u230b\u22c5i] \\begin{align*} dp[i][j] = &amp; dp[i - 1][j] + dp[i - 1][j - i] + dp[i - 1][j - 2\\cdot i] + \\dots + \\\\ &amp;dp[i - 1][j - \\lfloor \\frac{j}{i} \\rfloor \\cdot i] \\end{align*} dp[i][j]=\u200bdp[i\u22121][j]+dp[i\u22121][j\u2212i]+dp[i\u22121][j\u22122\u22c5i]+\u22ef+dp[i\u22121][j\u2212\u230aij\u200b\u230b\u22c5i]\u200b</p> </li> <li>Optimization: Since each item in the sum above is iii distance apart, a vector is used to record the sums whose elements are iii distance part.</li> <li>Arbitrary-precision arithmetic.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1065","title":"POJ 1065","text":"<p> Problem  Code</p> <ul> <li>Essentially, the result is the minimum number of nondecreasing subsequences. </li> <li>Use <code>std::set</code> to keep the last element of the nondecreasing subsequences.</li> <li>Greedily append new elements eee to the nondecreasing subsequence whose last element is closest to but not exceeding eee.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1631","title":"POJ 1631","text":"<p> Problem  Code</p> <ul> <li>Longest Increasing Subsequence.</li> <li>dp[i]\u2254 dp[i] \\coloneqq dp[i]:= the minimum value of the last elements in an increasing subsequence of length i+1i + 1i+1.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3666","title":"POJ 3666","text":"<p> Problem  Code</p> <ul> <li>Bi\u2208{A1,A2,\u2026,AN}B_i \\in \\{ A_1, A_2, \\dots, A_N \\}Bi\u200b\u2208{A1\u200b,A2\u200b,\u2026,AN\u200b}.</li> <li>Assuming that there are KKK distinct numbers U1,U2,U3,\u2026,UKU_1, U_2, U_3, \\dots, U_KU1\u200b,U2\u200b,U3\u200b,\u2026,UK\u200b in  {A1,A2,\u2026,AN} \\{ A_1, A_2, \\dots, A_N \\} {A1\u200b,A2\u200b,\u2026,AN\u200b} where U1&lt;U2&lt;U3&lt;\u22ef&lt;UK U_1 &lt; U_2 &lt; U_3 &lt; \\dots &lt; U_K U1\u200b&lt;U2\u200b&lt;U3\u200b&lt;\u22ef&lt;UK\u200b, a nondecreasing sequence B1,B2,B3,\u2026,BN B_1, B_2, B_3, \\dots, B_N B1\u200b,B2\u200b,B3\u200b,\u2026,BN\u200b can be represented as Ut1,Ut2,Ut3,\u2026,UtN U_{t_1}, U_{t_2}, U_{t_3}, \\dots, U_{t_N} Ut1\u200b\u200b,Ut2\u200b\u200b,Ut3\u200b\u200b,\u2026,UtN\u200b\u200b  where 1\u2264t1\u2264t2\u2264\u22ef\u2264tN\u2264K 1 \\le t_1 \\le t_2 \\le \\dots \\le t_N \\le K 1\u2264t1\u200b\u2264t2\u200b\u2264\u22ef\u2264tN\u200b\u2264K.</li> <li>dp[i][j]\u2254 dp[i][j] \\coloneqq dp[i][j]:= the minimum cost to adjust A1,\u2026Ai A_1, \\dots A_i A1\u200b,\u2026Ai\u200b to a new sequence ended in UjU_{j}Uj\u200b.</li> <li> <p>dp[i][j]={0(i=0)min\u20611\u2264k\u2264j{dp[i\u22121][k]+\u2223Ai\u2212Uk\u2223}(i&gt;0) dp[i][j] = \\begin{cases} 0                                                                &amp; (i = 0) \\\\ \\min_{1 \\le k \\le j}{\\{ dp[i - 1][k] + |A_i - U_k | \\} }  &amp; (i &gt; 0) \\\\ \\end{cases} dp[i][j]={0min1\u2264k\u2264j\u200b{dp[i\u22121][k]+\u2223Ai\u200b\u2212Uk\u200b\u2223}\u200b(i=0)(i&gt;0)\u200b</p> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2392","title":"POJ 2392","text":"<p> Problem  Code</p> <ul> <li>dp[i+1][j]\u2254dp[i + 1][j] \\coloneqq dp[i+1][j]:= the maximum number of blocks iii left when building a space elevator of height jjj using blocks from 000 to iii, \u22121-1\u22121 if there's no feasible solution.</li> <li> <p>dp[i+1][j]={\u22121(j&gt;ai)ci(dp[i][j]\u22650)\u22121(j&lt;hi\u2228dp[i+1][j\u2212hi]\u22640)dp[i+1][j\u2212hi]\u22121(otherwise) dp[i + 1][j] = \\begin{cases}   -1                            &amp; (j &gt; a_i) \\\\   c_i                           &amp; (dp[i][j] \\ge 0) \\\\   -1                            &amp; (j &lt; h_i \\lor dp[i + 1][j - h_i] \\le 0) \\\\   dp[i + 1][j - h_i] - 1 &amp; (\\text{otherwise}) \\\\ \\end{cases} dp[i+1][j]=\u23a9\u23a8\u23a7\u200b\u22121ci\u200b\u22121dp[i+1][j\u2212hi\u200b]\u22121\u200b(j&gt;ai\u200b)(dp[i][j]\u22650)(j&lt;hi\u200b\u2228dp[i+1][j\u2212hi\u200b]\u22640)(otherwise)\u200b</p> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2184","title":"POJ 2184","text":"<p> Problem  Code</p> <ul> <li>0-1 Knapsack Problem and Hashing: In hash table, the key is sum of \"Smartness\" and the value is the maximum sum of \"Funness\".</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#24","title":"2.4","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3614","title":"POJ 3614","text":"<p> Problem  Code</p> <ul> <li>Use lotions from small <code>SPF</code> to large <code>SPF</code>. If there are multiple cows that can be protected by a lotion, we first protect the cows with smaller <code>maxSPF</code>.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2010","title":"POJ 2010","text":"<p> Problem  Code</p> <ul> <li>Sort the cows by score.</li> <li>For each candidate of the median score, the min sum of financial aids should be L+C+RL + C + RL+C+R:<ul> <li>LLL is the min sum of any N2\\frac{N}{2}2N\u200b cows's finanial aid before the candidate.</li> <li>RRR is the min sum of any N2\\frac{N}{2}2N\u200b cows's finanial aid after the candidate.</li> <li>CCC is the candidate's financial aid.</li> </ul> </li> <li>During calculate LLL (or RRR) for each candidate of the median score, keep the N2\\frac{N}{2}2N\u200b cows of LLL (or RRR) in a <code>std::priority_queue</code>.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2236","title":"POJ 2236","text":"<p> Problem  Code</p> <ul> <li>Naive union-find.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1703","title":"POJ 1703","text":"<p> Problem  Code</p> <ul> <li>Union-find and equivalence classes.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2170","title":"AOJ 2170","text":"<p> Problem  Code</p> <ul> <li>Union-find and path compression.</li> <li>In this problem, after a node is marked, current disjoint sets would be further splitted into a larger number of disjoint sets. So the query/mark operations are kept in a sequence and handled in reverse order, which would convert splitting operations into union operations.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#25","title":"2.5","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-0189","title":"AOJ 0189","text":"<p> Problem  Code</p> <ul> <li>All-pairs shortest path: the Floyd-Warshall algorithm.</li> <li>CAUTION: The numbers of vertices might not be consecutive numbers.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2139","title":"POJ 2139","text":"<p> Problem  Code</p> <ul> <li>All-pairs shortest path: the Floyd-Warshall algorithm.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3259","title":"POJ 3259","text":"<p> Problem  Code</p> <ul> <li>Single-source shortest path: the Bellman-Ford algorithm.</li> <li>Negative cycle detection using the Bellman-Ford algorithm.<ul> <li>A global source vertex numbered 000 is added to the vertex set.</li> <li>NNN edges, from vertex 000 to vertex 1,2,\u2026,N1, 2, \\dots, N1,2,\u2026,N are added to the edge set.</li> <li>Vertex 000 is used as the single-source in the Bellman-Ford algorithm.</li> </ul> </li> <li>Time complexity analysis:<ul> <li>In this problem, the graph contains at most V=N=500V = N = 500V=N=500 vertices and E=M\u22172+W=5200E = M * 2 + W = 5200E=M\u22172+W=5200 edges.</li> <li>If the Floyd-Warshall algorithm is used to detect negative cycle, the time complexity would be O(V3)\\mathcal{O}(V^3)O(V3). Since V3\u2248108V^3 \\approx 10^8 V3\u2248108, it is unacceptable.</li> <li>The time complexity of the Bellman-Ford algorithm is O(V\u22c5E) \\mathcal{O}(V \\cdot E) O(V\u22c5E). Since V\u22c5E\u2248106 V \\cdot E \\approx 10^6 V\u22c5E\u2248106, it is acceptable.</li> </ul> </li> <li>CAUTION: Pay attention to the statement: \"Two fields might be connected by more than one path\". That's to say, if there are more than one path between two fields, the path with minimum time cost should be taken as the edge.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3268","title":"POJ 3268","text":"<p> Problem  Code</p> <ul> <li>Single-source shortest path: the Bellman-Ford algorithm.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2249","title":"AOJ 2249","text":"<p> Problem  Code</p> <ul> <li>Single-source shortest path: the Bellman-Ford algorithm.</li> <li>Since the final plan must corresponds to a tree rooted by the capital, we just need to keep the cost of the incoming edge to a city. And if two incoming edges both result in the minimum distance, we should choose the one with less cost.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2200","title":"AOJ 2200","text":"<p> Problem  Code</p> <ul> <li>The Floyd-Warshall algorithm and dynamic programming.</li> <li>L[a][b]\u2254 L[a][b] \\coloneqq L[a][b]:= the shortest travel time from aaa to bbb without using a boat.</li> <li>S[a][b]\u2254 S[a][b] \\coloneqq S[a][b]:= the shortest travel time from aaa to bbb by boat.</li> <li>z0\u2192z1\u2192\u22ef\u2192zR\u22121\u2254 z_0 \\to z_1 \\to \\cdots \\to z_{R-1} \\coloneqq z0\u200b\u2192z1\u200b\u2192\u22ef\u2192zR\u22121\u200b:=  the order of collection / delivery.</li> <li>(x,y)\u2254 (x, y) \\coloneqq (x,y):= the state that the postal carrier is in the town xxx and the boat is in the town yyy.</li> <li>dp[i][j]\u2254 dp[i][j] \\coloneqq dp[i][j]:= the shortest travel time from (z0,z0) (z_0, z_0) (z0\u200b,z0\u200b) to (zi,j) (z_i, j) (zi\u200b,j).</li> <li> <p>dp[i][j]={0(i=0\u2227j=z0)\u221e(i=0\u2227j\u2260z0)dp[i\u22121][k]+L[zi][zi+1](i&gt;0\u2227k=j)min\u2061{dp[i\u22121][k]+L[zi][k]+S[k][j]+L[j][zi+1]}(i&gt;0\u2227k\u2260j) dp[i][j] = \\begin{cases}   0 &amp; (i = 0 \\land j = z_0) \\\\   \\infty &amp; (i = 0 \\land j \\ne z_0) \\\\   dp[i - 1][k] + L[z_{i}][z_{i + 1}] &amp; (i &gt; 0 \\land k = j)\\\\   \\min{ \\lbrace dp[i - 1][k] + L[z_{i}][k] + S[k][j] + L[j][z_{i + 1}] \\rbrace } &amp; (i &gt; 0 \\land k \\ne j) \\\\ \\end{cases} dp[i][j]=\u23a9\u23a8\u23a7\u200b0\u221edp[i\u22121][k]+L[zi\u200b][zi+1\u200b]min{dp[i\u22121][k]+L[zi\u200b][k]+S[k][j]+L[j][zi+1\u200b]}\u200b(i=0\u2227j=z0\u200b)(i=0\u2227j\ue020=z0\u200b)(i&gt;0\u2227k=j)(i&gt;0\u2227k\ue020=j)\u200b</p> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1258","title":"POJ 1258","text":"<p> Problem  Code</p> <ul> <li>Minimum Spanning Tree.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2377","title":"POJ 2377","text":"<p> Problem  Code</p> <ul> <li>A variant of Minimum Spanning Tree: Maximum Spanning Tree.</li> <li>CAUTION: The original graph may not be a connected graph and the result may be a minimum spanning forest.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2224","title":"AOJ 2224","text":"<p> Problem  Code</p> <ul> <li>The minimum length of edge removed to obtain a maximum spanning tree.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2395","title":"POJ 2395","text":"<p> Problem  Code</p> <ul> <li>The maximum edge length in the minimum spanning tree.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#26","title":"2.6","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-0005","title":"AOJ 0005","text":"<p> Problem  Code</p> <ul> <li>GCD and LCM.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2429","title":"POJ 2429","text":"<p> Problem  Code</p> <ul> <li>Miller-Rabin primality test.</li> <li>Integer factorization with Pollard's rho algorithm.</li> <li>DFS. The depth of DFS in this problem is at most 16 since we have the experiential knowledge:     <pre><code>2*3*5*7*11*13*17*19*23*29*31*37*41*43*47    = 0x0888 86FF DB34 4692\n2*3*5*7*11*13*17*19*23*29*31*37*41*43*47*53 = 0xC443 F2F8 61D2 9C3A\n</code></pre></li> <li>Some test cases for debugging.     <pre><code>21 614889782588491410\n// --&gt; 3577359786 3609557385\n// 614889782588491410 = 2*3*5*7*11*13*17*19*23*29*31*37*41*43*47\n\n13 6121863882679589928\n// --&gt; 7190755416 11067575779\n// 6121863882679589928 = 2*2*2*3*3*13*71*7682431*11990873\n\n17 3423517729149215872\n// --&gt; 2806947503 20734196608\n// 3423517729149215872 = 2*2*2*2*2*2*2*17*1433*115223*9528583\n</code></pre></li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1930","title":"POJ 1930","text":"<p> Problem  Code</p> <ul> <li>Converting a repeating decimal to a fraction.     <p>x=0.a1a2a3\u22efan\u203e10n\u22c5x=a1a2a3\u22efan.a1a2a3\u22efan\u203e(10n\u22121)\u22c5x=a1a2a3\u22efanx=a1a2a3\u22efan10n\u22121 \\begin{align*} x &amp;= 0.\\overline{a_1 a_2 a_3 \\cdots a_n} \\\\ 10^n \\cdot x &amp;= a_1 a_2 a_3 \\cdots a_n.\\overline{a_1 a_2 a_3 \\cdots a_n} \\\\ (10^n - 1) \\cdot x &amp;= a_1 a_2 a_3 \\cdots a_n \\\\ x &amp;= \\frac{a_1 a_2 a_3 \\cdots a_n}{10^n - 1} \\\\ \\end{align*} x10n\u22c5x(10n\u22121)\u22c5xx\u200b=0.a1\u200ba2\u200ba3\u200b\u22efan\u200b\u200b=a1\u200ba2\u200ba3\u200b\u22efan\u200b.a1\u200ba2\u200ba3\u200b\u22efan\u200b\u200b=a1\u200ba2\u200ba3\u200b\u22efan\u200b=10n\u22121a1\u200ba2\u200ba3\u200b\u22efan\u200b\u200b\u200b</p></li> <li>In this problem, the input 0.d1d2d3\u22efdn\u2026 0.d_1 d_2 d_3 \\cdots d_n\\dots 0.d1\u200bd2\u200bd3\u200b\u22efdn\u200b\u2026 might be interpreted as a repeating decimal whose repetend has kkk digits (1\u2264k\u2264n)(1 \\le k \\le n)(1\u2264k\u2264n). We need to convert the nnn repeating decimals to fractions and use GCD to get the simplest forms.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-0009","title":"AOJ 0009","text":"<p> Problem  Code</p> <ul> <li>Sieve of Eratosthenes and Prefix Sum.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3126","title":"POJ 3126","text":"<p> Problem  Code</p> <ul> <li>Sieve of Eratosthenes and BFS.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3421","title":"POJ 3421","text":"<p> Problem  Code</p> <ul> <li>Naive factorization: X=p1e1\u22c5p2e2\u22efpk\u22121ek\u22121\u22c5pkek X = p_{1}^{e_1} \\cdot p_{2}^{e_2}  \\cdots p_{k-1}^{e_{k-1}} \\cdot p_{k}^{e_k} X=p1e1\u200b\u200b\u22c5p2e2\u200b\u200b\u22efpk\u22121ek\u22121\u200b\u200b\u22c5pkek\u200b\u200b</li> <li>Maximum length: n=e1+e2+\u22ef+ek n = e_1 + e_2 + \\cdots + e_k n=e1\u200b+e2\u200b+\u22ef+ek\u200b</li> <li>Number of such X-factors chains:     x=(ne1)\u22c5(n\u2212e1e2)\u22c5(n\u2212e1\u2212e2e3)\u22ef(n\u2212e1\u2212\u22ef\u2212ek\u22121ek)=n!e1!e2!\u22efek! x = \\binom{n}{e_1} \\cdot \\binom{n - e_1}{e_2} \\cdot \\binom{n - e_1 - e_2}{e_3} \\cdots \\binom{n - e_1 - \\cdots - e_{k - 1}}{e_k} = \\frac{n!}{e_1! e_2! \\cdots e_k!} x=(e1\u200bn\u200b)\u22c5(e2\u200bn\u2212e1\u200b\u200b)\u22c5(e3\u200bn\u2212e1\u200b\u2212e2\u200b\u200b)\u22ef(ek\u200bn\u2212e1\u200b\u2212\u22ef\u2212ek\u22121\u200b\u200b)=e1\u200b!e2\u200b!\u22efek\u200b!n!\u200b</li> <li>Experiential knowledge:<ul> <li>20!&lt;263&lt;264&lt;21!20! &lt; 2^{63} &lt; 2^{64} &lt; 21!20!&lt;263&lt;264&lt;21!</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3292","title":"POJ 3292","text":"<p> Problem  Code</p> <ul> <li>Sieve of Eratosthenes, Precomputation, Prefix Sum.</li> <li>In this problem, an H-semi-prime number is an H-number which is the product of exact two H-primes. It's worth noting that while enumerating the product of two H-primes, the same H-semi-prime might be enumerated twice, e.g. 441=9\u00d749=21\u00d721 441 = 9 \\times 49 = 21 \\times 21 441=9\u00d749=21\u00d721.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3641","title":"POJ 3641","text":"<p> Problem  Code</p> <ul> <li>Binary exponentiation and primality test.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1995","title":"POJ 1995","text":"<p> Problem  Code</p> <ul> <li>Binary exponentiation.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#31","title":"3.1","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3258","title":"POJ 3258","text":"<p> Problem  Code</p> <ul> <li>Binary search: maximizing the minimum value / minimizing the maximum value.</li> <li>The shortest distance between two adjacent rocks     dmin\u2208[1,L] d_{\\text{min}} \\in [1, L] dmin\u200b\u2208[1,L].     And 1\u2264L\u2264109 1 \\le L \\le 10^9 1\u2264L\u2264109 implies that we should     apply binary search algorithm to the shortest distance.</li> <li>Hint: In order to make the shortest distance between two adjacent rocks     \u2265x \\ge x \u2265x, how many rocks must be removed at least?<ul> <li>S\u2254S \\coloneqqS:= a set of rocks that the distances between adjacent rocks   are all \u2265x \\ge x \u2265x.   Initally, the set SSS only contains the rock at the start.</li> <li>Scan from left to right, add the rock to the set SSS   if the distance from the rock to the rightmost rock in the set SSS   is greater than or equal to xxx, otherwise drop the rock.</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3273","title":"POJ 3273","text":"<p> Problem  Code</p> <ul> <li>Binary search: maximizing the minimum value / minimizing the maximum value.</li> <li>Hint: In order to make the expenses of each \"fajomonths\"     smaller than or equal to xxx,     how many \"fajomonths\" should be arranged at least?</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3104","title":"POJ 3104","text":"<p> Problem  Code</p> <ul> <li>Binary search: maximizing the minimum value / minimizing the maximum value.</li> <li>Hint: Could the clothes be dried in ttt minutes?</li> <li>CAUTION: On the radiator, the amount of water decreases by kkk     in each minute, not k+1k + 1k+1.</li> <li>In order to dry all clothes in ttt minutes, the radiator must be used     for the clothes that contains aia_iai\u200b amounts of water, where ai&gt;ta_i &gt; tai\u200b&gt;t.     For such clothes, the minimum time on the radiator should be     \u2308ai\u2212tk\u22121\u2309 \\lceil \\frac{a_i - t}{k - 1} \\rceil \u2308k\u22121ai\u200b\u2212t\u200b\u2309 minutes.</li> <li>CAUTION: \u2211i\u2308ai\u2212tk\u22121\u2309\\sum_{i} \\lceil \\frac{a_i - t}{k - 1} \\rceil \u2211i\u200b\u2308k\u22121ai\u200b\u2212t\u200b\u2309     could be larger than <code>INT_MAX</code>.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3045","title":"POJ 3045","text":"<p> Problem  Code</p> <ul> <li>Greedy algorithm.</li> <li>Proof:<ul> <li>Assume that swapping the iii-th cow and the (i+1)(i+1)(i+1)-th cow   from the bottom to the top could make the largest risk smaller.   Then the largest risk must be either the risk of the iii-th cow   or the risk of the (i+1)(i+1)(i+1)-th cow.</li> <li>Denote the sum of weight on the (i+1)(i+1)(i+1)-th cow by   XXX, i.e. X\u2254\u2211k=i+2NWkX \\coloneqq \\sum_{k = i + 2}^{N} W_{k}X:=\u2211k=i+2N\u200bWk\u200b.</li> <li>Before swapping, the largest risk is   <p>max\u2061{Wi+1+X\u2212Si,X\u2212Si+1} \\max\\{ W_{i+1} + X - S_{i}, X - S_{i+1} \\} max{Wi+1\u200b+X\u2212Si\u200b,X\u2212Si+1\u200b}</p></li> <li>After swapping, the largest risk is   <p>max\u2061{X\u2212Si,Wi+X\u2212Si+1} \\max\\{ X - S_{i}, W_{i} + X - S_{i+1} \\} max{X\u2212Si\u200b,Wi\u200b+X\u2212Si+1\u200b}</p></li> <li>Swapping could make the largest risk smaller implies   <p>max\u2061{Wi+1+X\u2212Si,X\u2212Si+1}&gt;max\u2061{X\u2212Si,Wi+X\u2212Si+1} \\max\\{ W_{i+1} + X - S_{i}, X - S_{i+1} \\} &gt; \\max\\{ X - S_{i}, W_{i} + X - S_{i+1} \\} max{Wi+1\u200b+X\u2212Si\u200b,X\u2212Si+1\u200b}&gt;max{X\u2212Si\u200b,Wi\u200b+X\u2212Si+1\u200b}</p></li> <li>Add Si+Si+1\u2212XS_{i} + S_{i+1} - XSi\u200b+Si+1\u200b\u2212X to both sides, we have   <p>max\u2061{Wi+1+Si+1,Si}&gt;max\u2061{Si+1,Wi+Si} \\max\\{ W_{i+1} + S_{i+1}, S_{i} \\} &gt; \\max\\{ S_{i+1}, W_{i} +S_{i} \\} max{Wi+1\u200b+Si+1\u200b,Si\u200b}&gt;max{Si+1\u200b,Wi\u200b+Si\u200b}</p></li> <li>This holds as long as Wi+1+Si+1&gt;Wi+SiW_{i+1} + S_{i+1} &gt; W_{i} +S_{i}Wi+1\u200b+Si+1\u200b&gt;Wi\u200b+Si\u200b holds,   since Wi+1+Si+1&gt;Si+1W_{i+1} + S_{i+1} &gt; S_{i+1}Wi+1\u200b+Si+1\u200b&gt;Si+1\u200b holds   and Si&lt;Wi+SiS_{i} &lt; W_{i} + S_{i}Si\u200b&lt;Wi\u200b+Si\u200b holds.</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2976","title":"POJ 2976","text":"<p> Problem  Code</p> <ul> <li>Binary search: maximizing / minimizing the average value.</li> <li>Denote the cumulative average by xxx and     denote the indices of the n\u2212kn-kn\u2212k tests by SSS:     <p>\u2203S={i1,i2,\u22ef ,in\u2212k}\u2282{1,2,\u22ef ,n}:100\u22c5\u2211i\u2208Sai\u2211i\u2208Sbi\u2265x \u27f9 \u2203S={i1,i2,\u22ef ,in\u2212k}\u2282{1,2,\u22ef ,n}:\u2211i\u2208S(ai\u22c5100\u2212bi\u22c5x)\u22650 \\begin{align*} &amp; \\exists S = \\{ i_1, i_2, \\cdots, i_{n-k}\\} \\subset \\{ 1, 2, \\cdots, n \\}: 100 \\cdot \\frac{\\sum_{i \\in S}{a_{i}}}{\\sum_{i \\in S}{b_{i}}} \\ge x \\\\ &amp; \\implies \\\\ &amp; \\exists S = \\{ i_1, i_2, \\cdots, i_{n-k}\\} \\subset \\{ 1, 2, \\cdots, n \\}: \\sum_{i \\in S}{(a_{i} \\cdot 100 - b_{i} \\cdot x)} \\ge 0 \\end{align*} \u200b\u2203S={i1\u200b,i2\u200b,\u22ef,in\u2212k\u200b}\u2282{1,2,\u22ef,n}:100\u22c5\u2211i\u2208S\u200bbi\u200b\u2211i\u2208S\u200bai\u200b\u200b\u2265x\u27f9\u2203S={i1\u200b,i2\u200b,\u22ef,in\u2212k\u200b}\u2282{1,2,\u22ef,n}:i\u2208S\u2211\u200b(ai\u200b\u22c5100\u2212bi\u200b\u22c5x)\u22650\u200b</p></li> <li>Such SSS exists as long as the sum of the maximum (n\u2212k)(n - k)(n\u2212k) values     of (ai\u22c5100\u2212bi\u22c5x)(a_{i} \\cdot 100 - b_{i} \\cdot x)(ai\u200b\u22c5100\u2212bi\u200b\u22c5x) is \u22650 \\ge 0 \u22650.</li> <li>CAUTION: Greedy algorithm does not work for this problem.     That's to say, the cumulative average of the maximum (n\u2212k)(n-k)(n\u2212k) values     of aibi\\frac{a_i}{b_i}bi\u200bai\u200b\u200b is not the highest cumulative average.     The sample input gives the indication.     Drop <code>1</code> test in <code>3</code> tests: <code>5/5</code>, <code>0/1</code>, <code>2/6</code>.     The highest cumulative average should be <code>(5+0)/(5+1)</code>.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3111","title":"POJ 3111","text":"<p> Problem  Code</p> <ul> <li>Binary search: maximizing / minimizing the average value.</li> <li>Use <code>maxSpecific</code> and <code>res[MAX_K + 1]</code> to keep the result     since the predicate function might return false in the last iteration.</li> <li>Binary search on real values in the the 1EEE 754 standard:     <pre><code>double l_real = 0, r_real = 1E7;\nint64_t l, r;\nmemcpy(&amp;l, &amp;l_real, sizeof(double)); // std::bit_cast since C++20.\nmemcpy(&amp;r, &amp;r_real, sizeof(double));\nwhile (l &lt; r) {\nint64_t x = l + (r - l) / 2;\ndouble x_real;\nmemcpy(&amp;x_real, &amp;x, sizeof(double));\nif (pred(x_real)) {\nl = x + 1;\n} else {\nr = x;\n}\n}\n</code></pre></li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3579","title":"POJ 3579","text":"<p> Problem  Code</p> <ul> <li>Binary search: find the kkk-th smallest / largest value.</li> <li>N\u2264105N \\le 10^5N\u2264105 and (n2)\u223c1010\\binom{n}{2} \\sim 10^{10}(2n\u200b)\u223c1010     implies <code>priority_queue</code> does not work for this problem.</li> <li>Use <code>scanf</code> and <code>printf</code> instead of <code>cin</code> and <code>cout</code>.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3685","title":"POJ 3685","text":"<p> Problem  Code</p> <ul> <li>Binary search: find the kkk-th smallest / largest value.</li> <li>N\u226450000N \\le 50000N\u226450000 and M\u2264N2M \\le N^2M\u2264N2     implies <code>priority_queue</code> does not work for this problem.</li> <li>For simplicity, the lower bound is initialized to \u2212105\u22c5N-10^5 \\cdot N\u2212105\u22c5N     and the upper bound is initialized to 3\u22c5N2+105\u22c5N3 \\cdot N^2 + 10^5 \\cdot N3\u22c5N2+105\u22c5N.     <p>f(i,j)=i2+105\u22c5i+j2\u2212105\u22c5j+i\u22c5j(1\u2264i\u2264N,1\u2264j\u2264N) \u27f9 \u2212105\u22c5N&lt;f(i,j)&lt;3\u22c5N2+105\u22c5N \\begin{align*} &amp; f(i, j) = i^2 + 10^5 \\cdot i + j^2 - 10^5 \\cdot j + i \\cdot j  \\qquad   (1 \\le i \\le N, 1 \\le j \\le N) \\\\ &amp; \\implies -10^5 \\cdot N &lt; f(i, j) &lt; 3 \\cdot N^2 + 10^5 \\cdot N \\end{align*} \u200bf(i,j)=i2+105\u22c5i+j2\u2212105\u22c5j+i\u22c5j(1\u2264i\u2264N,1\u2264j\u2264N)\u27f9\u2212105\u22c5N&lt;f(i,j)&lt;3\u22c5N2+105\u22c5N\u200b</p></li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2010_1","title":"POJ 2010","text":"<p> Problem  Code</p> <ul> <li>See <code>priority_queue</code> solution here.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3662","title":"POJ 3662","text":"<p> Problem  Code</p> <ul> <li>Binary Search and Dijkstra algorithm.</li> <li>In the given graph, for any path from vertex 111 to vertex NNN,     denote the (K+1)(K+1)(K+1)-th maximum edge length as xxx,     the aim is to find the minimum xxx among all paths.</li> <li>The key to the problem is to convert the graph.<ul> <li>W(t)\u2254(e1,e2,\u2026,et)W(t) \\coloneqq (e_1, e_2, \\dots, e_t) W(t):=(e1\u200b,e2\u200b,\u2026,et\u200b) denotes a walk   from 111 to NNN which is connected by $t$ edges   e1,e2,\u2026,ete_1, e_2, \\dots, e_te1\u200b,e2\u200b,\u2026,et\u200b.</li> <li>The lengths of the ttt edges are sorted in nondescending order:   L1\u2264L2\u2264\u22ef\u2264LtL_1 \\le L_2 \\le \\cdots \\le L_tL1\u200b\u2264L2\u200b\u2264\u22ef\u2264Lt\u200b.</li> <li>P(x)\u2254\u2203W(t):t\u2264K\u2228Lt\u2212K\u2264xP(x) \\coloneqq \\exists W(t): t \\le K \\lor L_{t - K} \\le x P(x):=\u2203W(t):t\u2264K\u2228Lt\u2212K\u200b\u2264x</li> <li>In this problem, P(x)P(x)P(x) indicates the amount of money   that Farmer John has to pay is less than or equal to xxx.</li> <li>Convert the original graph G(V,E)G(V, E)G(V,E) into a new graph   G\u2032(V,{0,1},x) G'(V, \\{0, 1\\}, x) G\u2032(V,{0,1},x):   \u2200e\u2208E:e\u2032=[e&gt;x]\u2208{0,1}\\forall e \\in E: e' = [e &gt; x] \\in \\{0, 1\\}\u2200e\u2208E:e\u2032=[e&gt;x]\u2208{0,1}.</li> <li>P(x) \u27fa P(x) \\iffP(x)\u27fa   In G\u2032(V,{0,1},x)G'(V, \\{0, 1\\}, x)G\u2032(V,{0,1},x), the shortest path from 111 to NNN   is less than or equal to KKK .</li> </ul> </li> <li>In this problem, V\u2264103V \\le 10^3V\u2264103 and E\u2264104E \\le 10^4E\u2264104.<ul> <li>The Dijkstra algorithm: O(Elog\u2061V)\u223c105\\mathcal{O}(E\\log{V}) \\sim 10^5O(ElogV)\u223c105</li> <li>Binary search between <code>0</code> and <code>INT_MAX</code>: at most 313131 times.</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1759","title":"POJ 1759","text":"<p> Problem  Code</p> <ul> <li>Binary search on real values.</li> <li>HNH_{N}HN\u200b gets larger as H2H_{2}H2\u200b gets larger:   <p> \u27f9 Hi=12(Hi\u22121+Hi+1)\u22121 \u27f9 Hi+1\u2212Hi=Hi\u2212Hi\u22121+2 \u27f9 HN\u2212HN\u22121=H2\u2212H1+2(N\u22122) \u27f9 HN\u2212H1=(N\u22121)(H2\u2212H1)+(N\u22121)(N\u22122) \u27f9 HN=(N\u22121)H2\u2212(N\u22122)H1+(N\u22121)(N\u22122) \\begin{align*}   &amp; \\phantom{\\implies} H_{i} = \\frac{1}{2}(H_{i - 1} + H_{i + 1}) - 1 \\\\   &amp; \\implies H_{i + 1} - H_{i} = H_{i} - H_{i - 1} + 2 \\\\   &amp; \\implies H_{N} - H_{N - 1} = H_{2} - H_{1} + 2(N - 2) \\\\   &amp; \\implies H_{N} - H_{1} = (N - 1) (H_{2} - H_{1}) + (N - 1)(N - 2) \\\\   &amp; \\implies H_{N} = (N - 1) H_{2} - (N - 2) H_{1} + (N - 1)(N - 2) \\end{align*} \u200b\u27f9Hi\u200b=21\u200b(Hi\u22121\u200b+Hi+1\u200b)\u22121\u27f9Hi+1\u200b\u2212Hi\u200b=Hi\u200b\u2212Hi\u22121\u200b+2\u27f9HN\u200b\u2212HN\u22121\u200b=H2\u200b\u2212H1\u200b+2(N\u22122)\u27f9HN\u200b\u2212H1\u200b=(N\u22121)(H2\u200b\u2212H1\u200b)+(N\u22121)(N\u22122)\u27f9HN\u200b=(N\u22121)H2\u200b\u2212(N\u22122)H1\u200b+(N\u22121)(N\u22122)\u200b</p></li> <li>To find the smallest HNH_{N}HN\u200b, we use binary search to     find the smallest H2H_{2}H2\u200b in [0,H1][0, H_{1}][0,H1\u200b] that makes     Hi\u22650H_i \\ge 0Hi\u200b\u22650 for 1\u2264i\u2264N1 \\le i \\le N1\u2264i\u2264N.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3484","title":"POJ 3484","text":"<p> Problem  Code</p> <ul> <li>Binary Search.<ul> <li>If the number of elements in all sequences is even,   there is no corruption in the data set.</li> <li>If the number of elements in all sequences is odd,   the only one element that occurs odd number of times should be   the smallest element in [xmin,ymax][x_{\\text{min}}, y_{\\text{max}}][xmin\u200b,ymax\u200b]   which has a even number of greater elements in all sequences.</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#32","title":"3.2","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2566","title":"POJ 2566","text":"<p> Problem  Code</p> <ul> <li>Sliding Window and Prefix Sum.</li> <li>For the original sequence {a1,a2,\u2026an}\\{ a_1, a_2, \\dots a_n \\}{a1\u200b,a2\u200b,\u2026an\u200b},     an sorted array of prefix sums {Sp1,Sp2,\u2026Spn}\\{ S_{p_1}, S_{p_2}, \\dots S_{p_n} \\}{Sp1\u200b\u200b,Sp2\u200b\u200b,\u2026Spn\u200b\u200b} is     computed, where Sp1\u2264Sp2\u2264\u22ef\u2264SpnS_{p_1} \\le S_{p_2} \\le \\dots \\le S_{p_n}Sp1\u200b\u200b\u2264Sp2\u200b\u200b\u2264\u22ef\u2264Spn\u200b\u200b and     Spk=\u2211i=1pkaiS_{p_k} = \\sum_{i = 1}^{p_k}{a_i}Spk\u200b\u200b=\u2211i=1pk\u200b\u200bai\u200b.</li> <li>Our objective is to find the subrange of sequence whose absolute value     of its sum is closest to ttt where (0\u2264t\u2264109)(0 \\le t \\le 10^9)(0\u2264t\u2264109).</li> <li>By definition,     <p>\u2223al+al+1+\u22ef+ar\u2223=\u2223Sr\u2212Sl\u22121\u2223=Spj\u2212Spi(l\u2264r,i&lt;j) |a_l + a_{l+1} + \\cdots + a_r| = |S_{r} - S_{l-1}| = S_{p_j} - S_{p_i} \\\\ (l \\le r, i &lt; j) \u2223al\u200b+al+1\u200b+\u22ef+ar\u200b\u2223=\u2223Sr\u200b\u2212Sl\u22121\u200b\u2223=Spj\u200b\u200b\u2212Spi\u200b\u200b(l\u2264r,i&lt;j)</p>     In this equation, finding (l,r)(l, r)(l,r) that meets the criteria above for {an}\\{ a_n \\}{an\u200b}     is equivalent to finding (pi,pj)(p_i, p_j)(pi\u200b,pj\u200b) that meets the criteria above for {Sn}\\{ S_n \\}{Sn\u200b},     is also equivalent to finding (i,j)(i, j)(i,j) for {Spn}\\{ S_{p_n} \\}{Spn\u200b\u200b}.     <p>{l=min\u2061{pi,pj}+1r=max\u2061{pi,pj} \\left\\{ \\begin{align*}   l &amp;= \\min{\\{ p_i, p_j \\}} + 1 \\\\   r &amp;= \\max{\\{ p_i, p_j \\}} \\\\ \\end{align*} \\right. {lr\u200b=min{pi\u200b,pj\u200b}+1=max{pi\u200b,pj\u200b}\u200b</p></li> <li>Sliding window can be used to find (i,j)(i, j)(i,j) for {Spn}\\{ S_{p_n} \\}{Spn\u200b\u200b}.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2739","title":"POJ 2739","text":"<p> Problem  Code</p> <ul> <li>Sliding Window and Sieve of Eratosthenes.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2100","title":"POJ 2100","text":"<p> Problem  Code</p> <ul> <li>Sliding Window.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3185","title":"POJ 3185","text":"<p> Problem  Code</p> <ul> <li>This problem is a variant of POJ 3276 where N=22N = 22N=22 and K=3K = 3K=3 if we add two bowls at two ends.</li> <li>A bowl never needs to be flipped more than once.</li> <li>For the leftmost bowl, flip it or not? It depends only on its own state.</li> <li>For other bowls, flip it or not? It not only depends on its own state, but also depends on whether the previous bowls are flipped.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1222","title":"POJ 1222","text":"<p> Problem  Code</p> <ul> <li>Enumeration.</li> <li>This problem is a variant of POJ 3279.</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2674","title":"POJ 2674","text":"<p> Problem  Code</p> <ul> <li>Perfect elastic collision and relative motion.<ul> <li>In this problem, if two inhabitants encounter each other, they would turn around and move in an opposite direction.   This is equivalent to the senario that they keep going but exchange their names.   Under the assumption that all inhabitants have the same constant value of velocity,   the last one to fall away must be the one that goes the longest distance before reaching the end.   That is either the leftmost one who goes right or the rightmost one who goes left.</li> <li>All inhabitants in the same direction can be treated as a whole.   Their relative position remains unchanged before/after collisions.</li> </ul> </li> <li> <p>Assume that the initial positions and names are recorded in <code>pos[]</code> and <code>name[]</code>.     And the inhabitant in <code>pos[i]</code> is last one to fall away.</p> <ul> <li>If the inhabitant in <code>pos[i]</code> is the leftmost one who goes right;   and on the right of <code>pos[i]</code>, there are <code>k</code> inhabitants going left.   Then the last one to fall away is <code>name[i + k]</code>.</li> <li>If the inhabitant in <code>pos[i]</code> is the rightmost one who goes left;   and on the left of <code>pos[i]</code>, there are <code>k</code> inhabitants going right.   Then the last one to fall away is <code>name[i - k]</code>.</li> </ul> </li> <li> <p>CAUTION: </p> <ul> <li><code>printf(\"%.2f\\n\", 1.777f);</code> would print <code>1.78</code> rather than <code>1.77</code>.   The integer after <code>.</code> in the format specifier specifies precision of the conversion. The value is not truncated.</li> <li><code>scanf(\" %c\", &amp;ch);</code> should be used to consume all leading whitespace (including <code>'\\n'</code> in the last input line) before reading a character.   Pay attention to the space before <code>%c</code> in the format specifier.</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3977","title":"POJ 3977","text":"<p> Problem  Code</p> <ul> <li>Enumeration and binary search.</li> <li>For N=35N = 35N=35, there are 2352^{35}235 possible results.     Based on our experiences, it's infeasible to enumerate all of them in the given time.     But it's feasible to enumerate 2202^{20}220 results in the given time.     Therefore, divide the N(\u226435)N (\\le 35)N(\u226435) numbers into two parts (N=A+B,A\u226420,B\u226420N = A + B, A \\le 20, B \\le 20N=A+B,A\u226420,B\u226420).     To get the minimum absolute sum and the number of elements in the optimal subset, there are three cases:<ul> <li>Case 1: The numbers in the optimal subset are all from the first part.</li> <li>Case 2: The numbers in the optimal subset are all from the second part.</li> <li>Case 3: The numbers in the optimal subset are chosen from both parts.</li> </ul> </li> <li>For Case 1 or Case 2, it is feasible to enumerate all 2A\u221212^{A} - 12A\u22121 or 2B\u221212^{B} - 12B\u22121 non-empty subsets in the given time.</li> <li>For Case 3, we could enumerate the possible optimal subsets in O(A\u22c5(2A+2B))\\mathcal{O}(A \\cdot (2^A + 2^B))O(A\u22c5(2A+2B)) time.<ul> <li>A non-empty subset in Case 3 corresponds to one non-empty subset in Case 1 and one non-empty subset in Case 2.</li> <li>For the 2A\u221212^A - 12A\u22121 non-empty subsets in Case 1, sort these subsets by their sums.   And if some subsets have the same value of sums, keep the one subset with the fewest numbers.   Such processing can be done in O(2A\u22c5A)\\mathcal{O}(2^A \\cdot A)O(2A\u22c5A) time and we use XXX to denote the processing result.</li> <li>For each of the 2B\u221212^B - 12B\u22121 non-empty subsets in Case 2, use sss to represent its sum.   In order to get the minimum absolute sum of the 2A\u221212^A - 12A\u22121 possibities,   binary search \u2212s-s\u2212s in XXX to get an index iii, where Xi\u22121&lt;\u2212sX_{i - 1} &lt; -sXi\u22121\u200b&lt;\u2212s and Xi\u2265sX_{i} \\ge sXi\u200b\u2265s.   The minimum absolute sum of the 2A\u221212^A - 12A\u22121 possibilities would be either \u2223s+Xi\u22121\u2223|s + X_{i - 1}|\u2223s+Xi\u22121\u200b\u2223 or \u2223s+Xi\u2223|s + X_i|\u2223s+Xi\u200b\u2223.   Such processing can be done in O(2B\u22c5A)\\mathcal{O}(2^B \\cdot A)O(2B\u22c5A) time.</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2549","title":"POJ 2549","text":"<p> Problem  Code</p> <ul> <li>The 3SUM problem<ul> <li>3SUM can be easily solved in O(N2)\\mathcal{O}(N^2)O(N2) time.</li> <li>To find the largest ddd such that a+b+c=da + b + c = da+b+c=d, enumerate ddd from large to small.</li> <li>Worst-case time complexity: O(N3)\\mathcal{O}(N^3)O(N3).</li> </ul> </li> <li>Also, enumeration and binary search can be used to solve this problem.<ul> <li>Enumerate all a+ba + ba+b and all d\u2212cd - cd\u2212c.</li> <li>Sort the enumerations of a+ba + ba+b.</li> <li>Binary search a value of d\u2212cd - cd\u2212c in the sorted enumerations of a+ba + ba+b.</li> <li>The elements between the lower bound and upper bound should be examined one by one until a feasible solution is found.   Therefore, the worst-case time complexity for this algorithm is not O(N2log\u2061N)\\mathcal{O}(N^{2} \\log{N})O(N2logN).</li> </ul> </li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-0531","title":"AOJ 0531","text":"<p> Problem  Code</p> <ul> <li>Discretization.</li> <li>In this problem, the key idea is to eliminate the rows (columns) that have the same color with their previous and next rows (columns).</li> </ul>"},{"location":"Exercises-ProgrammingContestChallengeBook2e/#33","title":"3.3","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1990","title":"POJ 1990","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3109","title":"POJ 3109","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2155","title":"POJ 2155","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2886","title":"POJ 2886","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3264","title":"POJ 3264","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3368","title":"POJ 3368","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3470","title":"POJ 3470","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1201","title":"POJ 1201","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#uva-11990","title":"UVa 11990","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#34","title":"3.4","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2441","title":"POJ 2441","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3254","title":"POJ 3254","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2836","title":"POJ 2836","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1795","title":"POJ 1795","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3411","title":"POJ 3411","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3420","title":"POJ 3420","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3735","title":"POJ 3735","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3171","title":"POJ 3171","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#35","title":"3.5","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3713","title":"POJ 3713","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2987","title":"POJ 2987","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2914","title":"POJ 2914","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3155","title":"POJ 3155","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1274","title":"POJ 1274","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2112","title":"POJ 2112","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1486","title":"POJ 1486","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1466","title":"POJ 1466","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3692","title":"POJ 3692","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2724","title":"POJ 2724","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2226","title":"POJ 2226","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2251","title":"AOJ 2251","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3068","title":"POJ 3068","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2195","title":"POJ 2195","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3422","title":"POJ 3422","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2266","title":"AOJ 2266","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2230","title":"AOJ 2230","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#36","title":"3.6","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1981","title":"POJ 1981","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1418","title":"POJ 1418","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2201","title":"AOJ 2201","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3168","title":"POJ 3168","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3293","title":"POJ 3293","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2482","title":"POJ 2482","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1113","title":"POJ 1113","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1912","title":"POJ 1912","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3608","title":"POJ 3608","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2079","title":"POJ 2079","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3246","title":"POJ 3246","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3689","title":"POJ 3689","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2256","title":"AOJ 2256","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2215","title":"AOJ 2215","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#41","title":"4.1","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1150","title":"POJ 1150","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1284","title":"POJ 1284","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2115","title":"POJ 2115","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3708","title":"POJ 3708","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2720","title":"POJ 2720","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#gcj-japan-2011-finals-b","title":"GCJ Japan 2011 Finals B","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2345","title":"POJ 2345","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3532","title":"POJ 3532","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3526","title":"POJ 3526","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2407","title":"POJ 2407","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1286","title":"POJ 1286","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2409","title":"POJ 2409","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2164","title":"AOJ 2164","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2214","title":"AOJ 2214","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#42","title":"4.2","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1082","title":"POJ 1082","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2068","title":"POJ 2068","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3688","title":"POJ 3688","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1740","title":"POJ 1740","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2975","title":"POJ 2975","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3537","title":"POJ 3537","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#codeforces-138d","title":"Codeforces 138D","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2315","title":"POJ 2315","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#43","title":"4.3","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3180","title":"POJ 3180","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1236","title":"POJ 1236","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3678","title":"POJ 3678","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2723","title":"POJ 2723","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2749","title":"POJ 2749","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1986","title":"POJ 1986","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3728","title":"POJ 3728","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#44","title":"4.4","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3250","title":"POJ 3250","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2082","title":"POJ 2082","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3494","title":"POJ 3494","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2823","title":"POJ 2823","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3260","title":"POJ 3260","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1180","title":"POJ 1180","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-1070","title":"AOJ 1070","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#45","title":"4.5","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1011","title":"POJ 1011","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2046","title":"POJ 2046","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3134","title":"POJ 3134","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3523","title":"POJ 3523","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2032","title":"POJ 2032","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#uva-10181","title":"UVa 10181","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#46","title":"4.6","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1854","title":"POJ 1854","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#gcj-2009-world-finals-b","title":"GCJ 2009 World Finals B","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#codeforces-97b","title":"Codeforces 97B","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-2114","title":"POJ 2114","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#uva-12161","title":"UVa 12161","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#spoj-qtree5","title":"SPOJ QTREE5","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#47","title":"4.7","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2212","title":"AOJ 2212","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#codeforces-86c","title":"Codeforces 86C","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#codeforces-25e","title":"Codeforces 25E","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-1312","title":"AOJ 1312","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-1509","title":"POJ 1509","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3415","title":"POJ 3415","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#poj-3729","title":"POJ 3729","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#aoj-2292","title":"AOJ 2292","text":""},{"location":"Exercises-ProgrammingContestChallengeBook2e/#codeforces-123d","title":"Codeforces 123D","text":""}]}